(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{311:function(n,e,t){"use strict";t.r(e);var r=t(0),i=Object(r.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("h1",{attrs:{id:"semaphore"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#semaphore"}},[this._v("#")]),this._v(" Semaphore")]),this._v(" "),e("div",{staticClass:"language-jav extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('public class Semaphore implements java.io.Serializable {\n    private static final long serialVersionUID = -3222578661600680210L;\n    private final Sync sync;\n\n\n    abstract static class Sync extends AbstractQueuedSynchronizer {\n        private static final long serialVersionUID = 1192457210091910933L;\n        Sync(int permits) { setState(permits); }\n        final int getPermits() { return getState(); }\n        final int nonfairTryAcquireShared(int acquire) {\n            for (;;) {\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining)) {\n                        return remaining;\n                }\n            }\n        }\n        \n        protected final boolean tryReleaseShared(int releases) {\n            for (;;) {\n                int current = getState();\n                int next = current + releases;\n                if (next < current)\n                    throw new Error("Maximum permit count exceeded");\n                if (compareAndSetState(current, next))\n                    return true;\n            }\n        }\n        \n        final void reducePermits(int reductions) {\n            for (;;) {\n                int current = getState();\n                int next = current - reductions;\n                if (next > current) // underflow\n                    throw new Error("Maximum permit count exceeded");\n                if (compareAndSetState(current, next))\n                    return;\n            }\n        }\n        \n        final int drainPermis() {\n            for (;;) {\n                int current = getState();\n                if (current == 0 || compareAndSetState(current, 0))\n                    return current;\n            }\n        }\n    }\n    \n    static final class NonfairSync extends Sync {\n        private static final long serialVersionUID = -2694183684443567898L;\n        NonfairSync(int permits) {\n            super(permits);\n        }\n\n        protected int tryAcquireShared(int acquires) {\n            return nonfairTryAcquireShared(acquires);\n        }\n    }\n    \n    static final class FairSync extends Sync {\n        private static final long serialVersionUID = 2014338818796000944L;\n        FairSync(int permits) {\n            super(permits);\n        }\n        protected int tryAcquireShared(int acquires) {\n            for (;;) {\n                if (hasQueuedPredecessors())\n                    return -1;\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                    return remaining;\n            }\n        }\n    }\n    \n    public Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\n    \n    public Semaphore(int permits, boolean fair) {\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n    }\n    \n    public void acquire() throws InterruptedException {\n        sync.acquireSharedInterruptibly(1);\n    }\n    \n    public void acquireUninterruptibly() {\n        sync.acquireShared(1);\n    }\n    \n    public boolean tryAcquire() {\n        return sync.nonfairTryAcquireShared(1) >= 0;\n    }\n    \n    public boolean tryAcquire(long timeout, TimeUnit unit)\n        throws InterruptedException {\n        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n    }\n    \n    public void release() {\n        sync.releaseShared(1);\n    }\n    \n    public void acquire(int permits) throws InterruptedException {\n        if (permits < 0) throw new IllegalArgumentException();\n        sync.acquireSharedInterruptibly(permits);\n    }\n    \n    public void acquireUninterruptibly(int permits) {\n        if (permits < 0) throw new IllegalArgumentException();\n        sync.acquireShared(permits);\n    }\n    \n    public boolean tryAcquire(int permits) {\n        if (permits < 0) throw new IllegalArgumentException();\n        return sync.nonfairTryAcquireShared(permits) >= 0;\n    }\n    \n    public boolean tryAcquire(int permits, long timeout, TimeUnit unit)\n        throws InterruptedException {\n        if (permits < 0) throw new IllegalArgumentException();\n        return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));\n    }\n    \n    public void release(int permits) {\n        if (permits < 0) throw new IllegalArgumentException();\n        sync.releaseShared(permits);\n    }\n    \n    public int availablePermits() {\n        return sync.getPermits();\n    }\n    \n    public int drainPermits() {\n        return sync.drainPermits();\n    }\n    \n    protected void reducePermits(int reduction) {\n        if (reduction < 0) throw new IllegalArgumentException();\n        sync.reducePermits(reduction);\n    }\n    \n    public boolean isFair() {\n        return sync instanceof FairSync;\n    }\n    \n    public final boolean hasQueuedThreads() {\n        return sync.hasQueuedThreads();\n    }\n    \n    public final int getQueueLength() {\n        return sync.getQueueLength();\n    }\n    \n    protected Collection<Thread> getQueuedThreads() {\n        return sync.getQueuedThreads();\n    }\n    \n    public String toString() {\n        return super.toString() + "[Permits = " + sync.getPermits() + "]";\n    }\n\n\n}\n')])])])])}),[],!1,null,null,null);e.default=i.exports}}]);